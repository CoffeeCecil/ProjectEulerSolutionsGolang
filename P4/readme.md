##Assemblies

This one, the main problem seems to be generating a palindrome detector in base 10.
So most of my assemblies aren't about that and there's no exported code.

What this project devolved into was race the data structure. It's based off the logic
of the Lua programming language for omitting an integer, the idea being that
processors can handle the floating point types as fast as an integer type, if not faster.

This suggested the following competition: stage the project euler 4 solution, and then
race the following data types to see which one came out fastest: int32, int64, float32, float64, and big.Int.
The main variation in the assemblies was in the formatting routines used to break down the number into a palindrome.

##Testing

The results generated by running go benchmarks can be summarized as follows:

|Name                      | #ran |  avg. runtime   | Bits/op       |   Allocations / op |
|:------------------------:|:----:|:---------------:|:-------------:|:------------------:|
|Benchmark_Eulerfour64-8   | 500  |  3370075 ns/op	| 715730 B/op	|   92814 allocs/op  |
|Benchmark_Eulerfour32-8   | 100  |  10474154 ns/op	| 1478047 B/op	|  185629 allocs/op  |
|Benchmark_Eulerfourf32B-8 | 100  |  11013698 ns/op	| 3685803 B/op	|  185628 allocs/op  |
|Benchmark_Eulerfourf64B-8 | 100  |  11383486 ns/op	| 3685803 B/op	|  185628 allocs/op  |
| Benchmark_EulerfourBig-8 | 100  |  19049261 ns/op	| 1485142 B/op	|  185635 allocs/op  |
| Benchmark_Eulerfourf32-8 | 50   |  23286706 ns/op	| 1818757 B/op	|  185629 allocs/op  |
| Benchmark_Eulerfourf64-8 | 50   |  27904028 ns/op	| 2228243 B/op	|  185630 allocs/op  | 

The memory allocations between a big.Ints and the float64s is just about the same. And, if you are 
counting by timing of the operation, float64s are slow to convert to strings. In spite of their 
'girth' though they end up exectuting noticeably faster than big if you use the correct function 
to convert them. The reason why these operations are not quicker based on size is because they have to rely
on functions that take a fixed data type size for testing palindromes.

In spite of the fact that the floats can possibly perform math faster, it appears that
integers beat them out. because of faster string conversions. By using a deficient algorithm
to get a string value (as in Eulerfour32, which ought to be at least as fast as the 64 version)
they can be made as slow as the floating point operations. It all basically comes down
to how palindromes are checked and which datastructure best converts to a string as
far as performance goes.

The implication of this is that for other projects where math operations are king
and printing isn't required, a float ought to be investigated for speed.

##Solution
An exectutable program that takes an argument n.
If no argument is passed prints out the solution.